---
title: "Network Analysis and Visualization"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output: 
  pdf_document:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message = FALSE, warning = FALSE)
```
This tutorial contains basics of network analysis and visualization with the R package igraph and statnet. The igraph library provides versatile options for descriptive network analysis and visualization in R.
A graph contains vertices (nodes) which are connected by edges (links). A graph may be undirected, meaning that there is no distinction between the two vertices associated with each edge, or its edges may be directed from one vertex to another.

1.1 R plots and colors
In most R functions, you can use named colors, hex, or RGB values. In the simple base R plot chart below, x and y are the point coordinates, pch is the point symbol shape, cex is the point size, and col is the color. To see the parameters for plotting in base R, check out ?par

```{r Plot}
plot(x=1:10, y=rep(5,10), pch=19, cex=3, col="dark red")
# see colors() for names of colors in R
#If you plan on using the built-in color names, here’s how to list all of them:
colors()                          # List all named colors

grep("blue", colors(), value=T)   # Colors that have "blue" in the name
points(x=1:10, y=rep(6, 10), pch=19, cex=3, col="557799") # a generic function for drawing
# RRGGBB where each of the pairs RR, GG, BB consist of two hexadecimal digits giving a value in the range 00 to FF
points(x=1:10, y=rep(4, 10), pch=19, cex=3, col=rgb(.25, .5, .3))
#You may notice that RGB here ranges from 0 to 1. While this is the R default, you can also set it for to the 0-255 range using something like rgb(10, 100, 100, maxColorValue=255).

# We can set the opacity/transparency of an element using the parameter alpha (range 0-1):
plot(x=1:5, y=rep(5,5), pch=19, cex=12, col=rgb(.25, .5, .3, alpha=.7), xlim=c(0,6))  

#In many cases, we need a number of contrasting colors, or multiple shades of a color. R comes with some predefined palette function that can generate those for us. For example:
```
# 1. "igraph" Package
```{r installation}
## installing packages:

#install.packages("igraph")
rm(list = ls()) # Remove all the objects we created so far.
library(igraph)
```
## Create networks
The following code generates an undirected graph with four edges. The numbers indicate vertex IDs, so the edges are 1–>2, 2–>3, 3–>1, 4->3.
```{r }
g1 <- graph( edges=c(1,2, 2,3, 3,1, 4,3), n=4, directed=F ) 
class(g1)
plot(g1) # A simple plot of the network - we'll talk more about plots later

# Now with 8 vertices, and directed by default:
g2 <- graph( edges=c(1,2, 2,3, 3,1), n=8 )
plot(g2)  
```

```{r named graphs}
g3 <- graph( c("Ali", "Reza", "Reza", "Hasan", "Hasan", "Ali")) # named vertices
# When the edge list has vertex names, the number of nodes is not needed
plot(g3)

g4 <- graph( c("Ali", "Reza", "Reza", "Hasan", "Reza", "Hasan", "Ali", "Ali"), isolates=c("Farid", "Fatemeh", "Zahra", "Sadegh") )  

# In named graphs we can specify isolates by providing a list of their names.

plot(g4, edge.arrow.size=.5, vertex.color="gold", vertex.size=15, 

     vertex.frame.color="gray", vertex.label.color="black", 

     vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.2) 
```

#Small graphs can also be generated by using symbols + and -:
#- for undirected tie, +- or -+ for directed ties pointing left & right, ++ for a symmetric tie, and “:” for sets of vertices.
```{R}
plot(graph_from_literal(a-b, b---c)) # the number of dashes doesn't matter
plot(graph_from_literal(a--+b, b+--c))
plot(graph_from_literal(a+-+b, b+-+c)) 
plot(graph_from_literal(a: b: c---c: d: e))
plot(graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f :i, j))
```
## Edge, vertex, and network attributes
Access vertices and edges:

```{r Edge-Vertex}
E(g4) # The edges of the object
V(g4) # The vertices of the object
g4[]  # Adjcency Matrix
g4[1,] 

```

### Add attributes to the network, vertices, or edges:

*Vertices and Edges attributes*: The weight attribute is treated in a special way for vertices and edges and can affect the result of some calculations, such as path lengths and centrality measures.

```{r Attribute}
vertex_attr(g4)
V(g4)$name # automatically generated when we created the network.
V(g4)$gender <- c("male", "male", "male", "male", "female", "female", "male")
vertex_attr(g4)

edge_attr(g4)
E(g4)$type <- c("email","classmate","colleague","email") # Edge attribute
E(g4)$weight <- c(10,5,4,2)    # Edge weight, setting all existing edges to 10
edge_attr(g4)  #Examine attributes:

graph_attr(g4)
# Another way to set attributes (you can similarly use set_edge_attr(), set_vertex_attr(), etc.):
g4 <- set_graph_attr(g4,name= "name",value= "facebook Network")
graph_attr(g4, "name")
g4 <- set_graph_attr(g4, "ID", "connections")
g4
g4 <- set_graph_attr(g4, "something", "A thing")
graph_attr(g4)
g4 <- delete_graph_attr(g4, "something")
plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
     vertex.color=c( "pink", "skyblue")[1+(V(g4)$gender=="male")] ) 

#The graph g4 has two edges going from Jim to Jack, and a loop from John to himself. We can simplify our graph to remove loops & multiple edges between the same nodes. Use edge.attr.comb to indicate how edge attributes are to be combined - possible options include sum, mean, prod (product), min, max, first/last (selects the first/last edge’s attribute). Option “ignore” says the attribute should be disregarded and dropped.

g4s <- simplify( g4, remove.multiple = T, remove.loops = F,         
                 edge.attr.comb=c(weight="sum", type="ignore") )

plot(g4s, vertex.label.dist=1.5)

g4s

```
## #The description of an igraph object starts with up to four letters:

#D or U, for a directed or undirected graph
N for a named graph (where nodes have a name attribute)
W for a weighted graph (where edges have a weight attribute)
B for a bipartite (two-mode) graph (where nodes have a type attribute)
The two numbers that follow (7 5) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:

(g/c) - graph-level character attribute
(v/c) - vertex-level character attribute
(e/n) - edge-level numeric attribute



##  Special graphs

### Empty graph
```{R}
empty <- make_empty_graph(40)
plot(empty, vertex.size=10, vertex.label=NA)

```
### Full graph
```{R}
full <- make_full_graph(40)
plot(full, vertex.size=10, vertex.label=NA)
```
### Simple star graph
```{R}
star <- make_star(40)
plot(star, vertex.size=10, vertex.label=NA) 
```
### Tree graph
```{R}
tree <- make_tree(40, children = 3, mode = "undirected")
plot(tree, vertex.size=10, vertex.label=NA) 
```
### Ring graph
```{R}
ring <- make_ring(40)
plot(ring, vertex.size=10, vertex.label=NA)
```
### Lattice graph
```{r}
latt <- make_lattice(c(5,5,5))
latt2 <- make_lattice(length = 5, dim = 3)
plot(latt2)

```

### Erdos-Renyi random graph model
(‘n’ is number of nodes, ‘m’ is the number of edges).
```{R}
er_gnm <- sample_gnm(n=100, m=40) 
plot(er_gnm, vertex.size=6, vertex.label=NA)  

er_gnp <- sample_gnp(1000, 1/1000)
plot(er_gnp, vertex.size=6, vertex.label=NA)  
```
### Watts-Strogatz small-world model
Creates a lattice (with dim dimensions and size nodes across dimension) and rewires edges randomly with probability p. The neighborhood in which edges are connected is nei. You can allow loops and multiple edges.
```{R}
sw <- sample_smallworld(dim=2, size=10, nei=1, p=0.1)
plot(sw, vertex.size=6, vertex.label=NA, layout=layout_in_circle)

```

### Barabasi-Albert preferential attachment model for scale-free graphs
(n is number of nodes, power is the power of attachment (1 is linear); m is the number of edges added on each time step)
```{R}
ba <-  sample_pa(n=100, power=1, m=1,  directed=F)
 plot(ba, vertex.size=6, vertex.label=NA)
```

### Rewiring a graph
each_edge() is a rewiring method that changes the edge endpoints uniformly randomly with a probability prob.
```{R}
rn.rewired <- rewire(ring, each_edge(prob=0.1))
plot(rn.rewired, vertex.size=10, vertex.label=NA)
```
## Reading network data from files
In the following sections of the tutorial, we will work primarily with two small example data sets. Both contain data about media organizations. One involves a network of hyperlinks and mentions among news sources. The second is a network of links between media venues and consumers. While the example data used here is small, many of the ideas behind the analyses and visualizations we will generate apply to medium and large-scale networks.

##  DATASET 1: edgelist
The first data set we are going to work with consists of two files, “Media-Example-NODES.csv” and “Media-Example-EDGES.csv”
```{R}
setwd("C:/Users/mirza/Desktop/R_Programming/Data")
nodes <- read.csv("Dataset1-Media-Example-NODES.csv", header=T, as.is=T)
links <- read.csv("Dataset1-Media-Example-EDGES.csv", header=T, as.is=T)

```

Examine the data

```{r}
head(nodes)

head(links)

nrow(nodes)
length(unique(nodes$id))

nrow(links);
nrow(unique(links[,c("from", "to")]))

```


```{r}
links <- aggregate(links[,3], links[,-3], sum)
links <- links[order(links$from, links$to),]
colnames(links)[4] <- "weight"
rownames(links) <- NULL

```
## DATASET 2: matrix
Two-mode or bipartite graphs have two different types of actors and links that go across, but not within each type. Our second media example is a network of that kind, examining links between news sources and their consumers.
```{r}
setwd("C:/Users/mirza/Desktop/R_Programming/Data")
nodes2 <- read.csv("Dataset2-Media-User-Example-NODES.csv", header=T, as.is=T)

links2 <- read.csv("Dataset2-Media-User-Example-EDGES.csv", header=T, row.names=1)

head(nodes2)

head(links2)
links2 <- as.matrix(links2)

dim(links2)

dim(nodes2)

```

## Turning networks into igraph objects
We start by converting the raw data to an igraph network object. Here we use igraph’s graph.data.frame function, which takes two data frames: d and vertices.

d describes the edges of the network. Its first two columns are the IDs of the source and the target node for each edge. The following columns are edge attributes (weight, type, label, or anything else).
vertices starts with a column of node IDs. Any following columns are interpreted as node attributes.

```{R}
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T) 
class(net)
net
E(net)       # The edges of the "net" object

V(net)       # The vertices of the "net" object

E(net)$type  # Edge attribute "type"

V(net)$media # Vertex attribute "media"
plot(net, edge.arrow.size=.4,vertex.label=NA)
net <- simplify(net, remove.multiple = F, remove.loops = T)

as_edgelist(net, names=T)

datafram_net <- as_data_frame(net, what="edges")

as_data_frame(net, what="vertices")
```

# graph from adjacency matrix

```{r}
net2 <- graph_from_incidence_matrix(links2)
V(net2)$type
table(V(net2)$type)
```
##Plotting networks with igraph
Plotting with igraph: the network plots have a wide set of parameters you can set. Those include node options (starting with vertex.) and edge options (starting with edge.). A list of selected options is included below, but you can also check out ?igraph.plotting for more information.

 

The igraph plotting parameters include (among others):

5.1 Plotting parameters
NODES	 
vertex.color	 Node color
vertex.frame.color	 Node border color
vertex.shape	 One of “none”, “circle”, “square”, “csquare”, “rectangle”
 “crectangle”, “vrectangle”, “pie”, “raster”, or “sphere”
vertex.size	 Size of the node (default is 15)
vertex.size2	 The second size of the node (e.g. for a rectangle)
vertex.label	 Character vector used to label the nodes
vertex.label.family	 Font family of the label (e.g.“Times”, “Helvetica”)
vertex.label.font	 Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol
vertex.label.cex	 Font size (multiplication factor, device-dependent)
vertex.label.dist	 Distance between the label and the vertex
vertex.label.degree	 The position of the label in relation to the vertex,
 where 0 right, “pi” is left, “pi/2” is below, and “-pi/2” is above
EDGES	 
edge.color	 Edge color
edge.width	 Edge width, defaults to 1
edge.arrow.size	 Arrow size, defaults to 1
edge.arrow.width	 Arrow width, defaults to 1
edge.lty	 Line type, could be 0 or “blank”, 1 or “solid”, 2 or “dashed”,
 3 or “dotted”, 4 or “dotdash”, 5 or “longdash”, 6 or “twodash”
edge.label	 Character vector used to label edges
edge.label.family	 Font family of the label (e.g.“Times”, “Helvetica”)
edge.label.font	 Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol
edge.label.cex	 Font size for edge labels
edge.curved	 Edge curvature, range 0-1 (FALSE sets it to 0, TRUE to 0.5)
arrow.mode	 Vector specifying whether edges should have arrows,
 possible values: 0 no arrow, 1 back, 2 forward, 3 both
OTHER	 
margin	 Empty space margins around the plot, vector with length 4
frame	 if TRUE, the plot will be framed
main	 If set, adds a title to the plot
sub	 If set, adds a subtitle to the plot
   

We can set the node & edge options in two ways - the first one is to specify them in the plot() function, as we are doing below.
```{R}
plot(net, edge.arrow.size=.4, edge.curved=.1)
plot(net, edge.arrow.size=.2, edge.curved=0,

     vertex.color="orange", vertex.frame.color="#555555",

     vertex.label=V(net)$media, vertex.label.color="black",

     vertex.label.cex=.7) 
```

## We can set the node & edge options in two ways - the first one is to specify them in the plot() function, as we are doing below.

```{r}
plot(net, edge.arrow.size=.4, edge.curved=.1)
# Set edge color to gray, and the node color to orange. 

# Replace the vertex label with the node names stored in "media"

plot(net, edge.arrow.size=.2, edge.curved=0,
   vertex.color="orange", vertex.frame.color="#555555",
     vertex.label=V(net)$media, vertex.label.color="black",
     vertex.label.cex=.7) 


```
The second way to set attributes is to add them to the igraph object. Let’s say we want to color our network nodes based on type of media, and size them based on audience size (larger audience -> larger node). We will also change the width of the edges based on their weight.

```{r}
# Generate colors based on media type:
colrs <- c("gray50", "tomato", "gold")
V(net)$color <- colrs[V(net)$media.type]
# Set node size based on audience size:
V(net)$size <- V(net)$audience.size*0.7
# The labels are currently node IDs.
# Setting them to NA will render no labels:
V(net)$label.color <- "black"
V(net)$label <- NA

# Set edge width based on weight:
E(net)$width <- E(net)$weight/6
#change arrow size and edge color:
E(net)$arrow.size <- .2
E(net)$edge.color <- "gray80"
E(net)$width <- 1+E(net)$weight/12
plot(net) 
legend(x=-1.5, y=-1.1, c("Newspaper","Television", "Online News"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)
```
Sometimes, especially with semantic networks, we may be interested in plotting only the labels of the nodes:

```{r}
plot(net, vertex.shape="none", vertex.label=V(net)$media, 
     vertex.label.font=2, vertex.label.color="gray40",
     vertex.label.cex=.7, edge.color="gray85")

```
Let’s color the edges of the graph based on their source node color. We can get the starting node for each edge with the ends() igraph function.

```{r}
edge.start <- ends(net, es=E(net), names=F)[,1]
edge.col <- V(net)$color[edge.start]
plot(net, edge.color=edge.col, edge.curved=.1)  
```
## Network layouts
Network layouts are simply algorithms that return coordinates for each node in a network.

For the purposes of exploring layouts, we will generate a slightly larger 80-node graph. We use the sample_pa() function which generates a simple graph starting from one node and adding more nodes and links based on a preset level of preferential attachment (Barabasi-Albert model).

```{r}
net.ba <- sample_pa(80) 

V(net.ba)$size <- 8

V(net.ba)$frame.color <- "white"

V(net.ba)$color <- "orange"

V(net.ba)$label <- "" 

E(net.ba)$arrow.mode <- 0

plot(net.ba)

#You can set the layout in the plot function:
plot(net.ba, layout=layout_randomly)
plot(net.ba, layout=layout_in_circle)
# you can easily generate your own layout
lay <- cbind(1:vcount(net.ba), c(1, vcount(net.ba):2))
plot(net.ba, layout=lay)

```
# Let’s take a look at all available layouts in igraph:

```{R}
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1] 
# Remove layouts that do not apply to our graph.
layouts <- layouts[!grepl("bipartite|merge|norm|sugiyama|tree", layouts)]
par(mfrow=c(3,3), mar=c(1,1,1,1))
for (layout in layouts) {
  print(layout)
  l <- do.call(layout, list(net)) 
  plot(net, edge.arrow.mode=0, layout=l, main=layout) 
  }
```
# Improving network plots
Notice that our network plot is still not too helpful. We can identify the type and size of nodes, but cannot see much about the structure since the links we’re examining are so dense. One way to approach this is to see if we can sparsify the network, keeping only the most important ties and discarding the rest.

```{r}
hist(links$weight)
mean(links$weight)
sd(links$weight)
```
There are more sophisticated ways to extract the key edges, but for the purposes of this exercise we’ll only keep ones that have weight higher than the mean for the network. In igraph, we can delete edges using delete_edges(net, edges):

```{r}
cut.off <- mean(links$weight) 

net.sp <- delete_edges(net, E(net)[weight<cut.off])

plot(net.sp) 
```
Another way to think about this is to plot the two tie types (hyperlink & mention) separately.
```{r}
E(net)$width <- 1.5
plot(net, edge.color=c("dark red", "slategrey")[(E(net)$type=="hyperlink")+1],
      vertex.color="gray40", layout=layout.circle)
```


```{r}
net.m <- net - E(net)[E(net)$type=="hyperlink"] # another way to delete edges
net.h <- net - E(net)[E(net)$type=="mention"]

# Plot the two links separately:
par(mfrow=c(1,2))
plot(net.h,vertex.color="orange", main="Tie:Hyperlink")
plot(net.m, vertex.color="lightsteelblue2", main="Tie: Mention")
dev.off()
```
# Interactive plotting with tkplot
R and igraph allow for interactive plotting of networks. This might be a useful option for you if you want to tweak slightly the layout of a small graph. After adjusting the layout manually, you can get the coordinates of the nodes and use them for other plots.
```{r}
tkid <- tkplot(net) #tkid is the id of the tkplot that will open
l <- tkplot.getcoords(tkid) # grab the coordinates from tkplot
tk_close(tkid, window.close = T)
plot(net, layout=l)
```
#At this point it might be useful to provide a quick reminder that there are many ways to represent a network not limited to a hairball plot.

For example, here is a quick heatmap of the network matrix:
```{r}
netm <- get.adjacency(net, attr="weight", sparse=F)

colnames(netm) <- V(net)$media

rownames(netm) <- V(net)$media

palf <- colorRampPalette(c("gold", "dark orange")) 

heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100), 
        scale="none", margins=c(10,10) )
heatmap(netm, Rowv = NA, Colv = NA, col = palf(100), 
        scale="none", margins=c(10,10) )

```

## Plotting bipartite networks.
As with one-mode networks, we can modify the network object to include the visual properties that will be used by default when plotting the network. Notice that this time we will also change the shape of the nodes - media outlets will be squares, and their users will be circles.

```{R}
V(net2)$color <- c("steel blue", "orange")[V(net2)$type+1]

V(net2)$shape <- c("square", "circle")[V(net2)$type+1]

V(net2)$label <- ""

V(net2)$label[V(net2)$type==F] <- nodes2$media[V(net2)$type==F] 

V(net2)$label.cex=.4

V(net2)$label.font=2

plot(net2, vertex.label.color="white", vertex.size=(2-V(net2)$type)*8) 

```
Igraph also has a special layout for bipartite networks (though it doesn’t always work great, and you might be better off generating your own two-mode layout).
```{R}
plot(net2, vertex.label=NA, vertex.size=7, layout=layout_as_bipartite) 
```

Using text as nodes may be helpful at times:
```{r}
plot(net2, vertex.shape="none", vertex.label=nodes2$media,
     vertex.label.color=V(net2)$color, vertex.label.font=2.5, 
     vertex.label.cex=.6, edge.color="gray70",  edge.width=2)

```
## Network Centralities

### Density
The proportion of present edges from all possible edges in the network.
```{R}
edge_density(net, loops=F)
ecount(net)/(vcount(net)*(vcount(net)-1)) #for a directed network
```
### Reciprocity
The proportion of reciprocated ties (for a directed network).
```{R}
reciprocity(net)
dyad_census(net) # Mutual, asymmetric, and nyll node pairs
2*dyad_census(net)$mut/ecount(net) # Calculating reciprocity

```

### Diameter
A network diameter is the longest geodesic distance (length of the shortest path between two nodes) in the network. In igraph, diameter() returns the distance, while get_diameter() returns the nodes along the first found path of that distance.

Note that edge weights are used by default, unless set to NA.

```{R}
diameter(net, directed=F, weights=NA)
diameter(net, directed=F)
diam <- get_diameter(net, directed=T)
class(diam)
as.vector(diam)
```
### Color nodes along the diameter:
```{R}
vcol <- rep("gray40", vcount(net))
vcol[diam] <- "gold"
ecol <- rep("gray80", ecount(net))
ecol[E(net, path=diam)] <- "orange" 
# E(net, path=diam) finds edges along a path, here 'diam'
plot(net, vertex.color=vcol, edge.color=ecol, edge.arrow.mode=0)

```
### Node degrees
The function degree() has a mode of in for in-degree, out for out-degree, and all or total for total degree.
```{R}
deg <- degree(net, mode="all")

plot(net, vertex.size=deg*3)
hist(deg, breaks=1:vcount(net)-1, main="Histogram of node degree")
deg.dist <- degree_distribution(net, cumulative=T, mode="all")

plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange", 

      xlab="Degree", ylab="Cumulative Frequency")
```
## Centrality & centralization
Centrality functions (vertex level) and centralization functions (graph level). The centralization functions return res - vertex centrality, centralization, and theoretical_max - maximum centralization score for a graph of that size. The centrality function can run on a subset of nodes (set with the vids parameter). This is helpful for large graphs where calculating all centralities may be a resource-intensive and time-consuming task.
```{R}
degree(net, mode="in")

deg <- centr_degree(net, mode="in", normalized=T)
```
### Closeness (centrality based on distance to others in the graph)
Inverse of the node’s average geodesic distance to others in the network.
```{r}
closeness(net, mode="all", weights=NA) 

centr_clo(net, mode="all", normalized=T) 
```
### Eigenvector (centrality proportional to the sum of connection centralities)
Values of the first eigenvector of the graph matrix.
```{R}
eigen_centrality(net, directed=T, weights=NA)

centr_eigen(net, directed=T, normalized=T) 
```
### Betweenness (centrality based on a broker position connecting others)
Number of geodesics that pass through the node or the edge.
```{R}
betweenness(net, directed=T, weights=NA)

edge_betweenness(net, directed=T, weights=NA)
centr_betw(net, directed=T, normalized=T)

```

##Hubs and authorities
The hubs and authorities algorithm developed by Jon Kleinberg was initially used to examine web pages. Hubs were expected to contain catalogs with a large number of outgoing links; while authorities would get many incoming links from hubs, presumably because of their high-quality relevant information.
```{R}
hs <- hub_score(net, weights=NA)$vector

as <- authority_score(net, weights=NA)$vector

par(mfrow=c(1,2))

plot(net, vertex.size=hs*50, main="Hubs")

plot(net, vertex.size=as*30, main="Authorities")
```

## Distances and paths
Average path length: the mean of the shortest distance between each pair of nodes in the network (in both directions for directed graphs).
```{r}
mean_distance(net, directed=F)
mean_distance(net, directed=T)
#We can also find the length of all shortest paths in the graph:
distances(net) # with edge weights

distances(net, weights=NA) # ignore weights
#We can extract the distances to a node or set of nodes we are interested in. Here we will get the distance of every media from the New York Times.
dist.from.NYT <- distances(net, v=V(net)[media=="NY Times"], to=V(net), weights=NA)
dist.from.NYT
# Set colors to plot the distances:
oranges <- colorRampPalette(c("dark red", "gold"))
col <- oranges(max(dist.from.NYT)+1)
col <- col[dist.from.NYT+1]
plot(net, vertex.color=col, vertex.label=dist.from.NYT, edge.arrow.size=.6,vertex.label.color="white")

# We can also find the shortest path between specific nodes. Say here between MSNBC and the New York Post:
news.path <- shortest_paths(net, from = V(net)[media=="MSNBC"], to  = V(net)[media=="New York Post"],output = "both") # both path nodes and edges
news.path
# Generate edge color variable to plot the path:
ecol <- rep("gray80", ecount(net))
ecol[unlist(news.path$epath)] <- "orange"

# Generate edge width variable to plot the path:
ew <- rep(2, ecount(net))

ew[unlist(news.path$epath)] <- 4

# Generate node color variable to plot the path:
vcol <- rep("gray40", vcount(net))

vcol[unlist(news.path$vpath)] <- "gold"
plot(net, vertex.color=vcol, edge.color=ecol, edge.width=ew, edge.arrow.mode=0)
```
Identify the edges going into or out of a vertex, for instance the WSJ. For a single node, use incident(), for multiple nodes use incident_edges()
```{R}
inc.edges <- incident(net,  V(net)[media=="Wall Street Journal"], mode="all")

# Set colors to plot the selected edges.

ecol <- rep("gray80", ecount(net))

ecol[inc.edges] <- "orange"

vcol <- rep("grey40", vcount(net))

vcol[V(net)$media=="Wall Street Journal"] <- "gold"

plot(net, vertex.color=vcol, edge.color=ecol)
```
We can also easily identify the immediate neighbors of a vertex, say WSJ. The neighbors function finds all nodes one step out from the focal actor.To find the neighbors for multiple nodes, use adjacent_vertices() instead of neighbors(). To find node neighborhoods going more than one step out, use function ego() with parameter order set to the number of steps out to go from the focal node(s).

```{R}
neigh.nodes <- neighbors(net, V(net)[media=="Wall Street Journal"], mode="out")

# Set colors to plot the neighbors:
vcol[neigh.nodes] <- "#ff9d00"

plot(net, vertex.color=vcol)

```
Special operators for the indexing of edge sequences: %–%, %->%, %<-%
* E(network)[X %–% Y] selects edges between vertex sets X and Y, ignoring direction
* E(network)[X %->% Y] selects edges from vertex sets X to vertex set Y
* E(network)[X %<-% Y] selects edges from vertex sets Y to vertex set X

For example, select edges from newspapers to online sources:
```{R}
E(net)[ V(net)[type.label=="Newspaper"] %->% V(net)[type.label=="Online"] ]
#Co-citation (for a couple of nodes, how many shared nominations they have):
cocitation(net)
```
###Subgroups and communities
Before we start, we will make our network undirected. There are several ways to do that conversion:

We can create an undirected link between any pair of connected nodes (mode="collapse")
Create undirected link for each directed one in the network, potentially ending up with a multiplex graph (mode="each")
Create undirected link for each symmetric link in the graph (mode="mutual").
In cases when we may have ties A -> B and B -> A ties collapsed into a single undirected link, we need to specify what to do with their edge attributes using the parameter ‘edge.attr.comb’ as we did earlier with simplify(). Here we have said that the ‘weight’ of the links should be summed, and all other edge attributes ignored and dropped.
```{R}
net.sym <- as.undirected(net, mode= "collapse", edge.attr.comb=list(weight="sum","ignore"))
```
###Cliques
Find cliques (complete subgraphs of an undirected graph)
```{R}
cliques(net.sym) # list of cliques       

sapply(cliques(net.sym), length) # clique sizes

largest_cliques(net.sym) # cliques with max number of nodes
vcol <- rep("grey80", vcount(net.sym))

vcol[unlist(largest_cliques(net.sym))] <- "gold"

plot(as.undirected(net.sym), vertex.label=V(net.sym)$name, vertex.color=vcol)

```
### Community detection
A number of algorithms aim to detect groups that consist of densely connected nodes with fewer connections across groups.

Community detection based on edge betweenness (Newman-Girvan)
High-betweenness edges are removed sequentially (recalculating at each step) and the best partitioning of the network is selected.
```{R}
ceb <- cluster_edge_betweenness(net) 

dendPlot(ceb, mode="hclust")
plot(ceb, net) 
#Let’s examine the community detection igraph object:
class(ceb)
length(ceb)     # number of communities
membership(ceb) # community membership for each node
modularity(ceb) # how modular the graph partitioning is
crossing(ceb, net)   # boolean vector: TRUE for edges across communities

```
High modularity for a partitioning reflects dense connections within communities and sparse connections across communities.

### Community detection based on propagating labels
Assigns node labels, randomizes, than replaces each vertex’s label with the label that appears most frequently among neighbors. Those steps are repeated until each vertex has the most common label of its neighbors.
```{r}
clp <- cluster_label_prop(net)

plot(clp, net)
```
Community detection based on greedy optimization of modularity
```{r}
cfg <- cluster_fast_greedy(as.undirected(net))
plot(cfg, as.undirected(net))
#We can also plot the communities without relying on their built-in plot:
V(net)$community <- cfg$membership

colrs <- adjustcolor( c("gray50", "tomato", "gold", "yellowgreen"), alpha=.6)

plot(net, vertex.color=colrs[V(net)$community])
```
###K-core decomposition
The k-core is the maximal subgraph in which every node has degree of at least k. The result here gives the coreness of each vertex in the network. A node has coreness D if it belongs to a D-core but not to (D+1)-core.
```{r}
kc <- coreness(net, mode="all")
plot(net, vertex.size=kc*6, vertex.label=kc, vertex.color=colrs[kc])
```
### Assortativity and Homophily
Homophily: the tendency of nodes to connect to others who are similar on some variable.

assortativity_nominal() is for categorical variables (labels)
assortativity() is for ordinal and above variables
assortativity_degree() checks assortativity in node degrees
```{r}
assortativity_nominal(net, V(net)$media.type, directed=F)
assortativity(net, V(net)$audience.size, directed=F)
assortativity_degree(net, directed=F)

```
