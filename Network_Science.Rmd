---
title: "Network Analysis and Visualization"
date: "Last update: `r format(Sys.time(), '%d %B, %Y')`" 
output: 
  pdf_document:
    toc: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,message = FALSE, warning = FALSE)
```
This tutorial contains basics of network analysis and visualization with the R package igraph and statnet. The igraph library provides versatile options for descriptive network analysis and visualization in R.
A graph contains vertices (nodes) which are connected by edges (links). A graph may be undirected, meaning that there is no distinction between the two vertices associated with each edge, or its edges may be directed from one vertex to another.
 

 1. Package Installation
 2. Matrices in R
 3. Simple Network Generation
 4. Network Attributes
 5. Special Types of Graphs (Standard Structures)
 6. Preparing Network Data 
 7. Network Descriptives
 8. Centrality and Distances
 9. Subgraphs and Communities
10. Statistical Inferences
11. Graph Visualization
12. Network plot improvement

1.1 R plots and colors
In most R functions, you can use named colors, hex, or RGB values. In the simple base R plot chart below, x and y are the point coordinates, pch is the point symbol shape, cex is the point size, and col is the color. To see the parameters for plotting in base R, check out ?par

```{r Plot}
plot(x=1:10, y=rep(5,10), pch=19, cex=3, col="dark red")
# see colors() for names of colors in R
#If you plan on using the built-in color names, here’s how to list all of them:
colors()                          # List all named colors

grep("blue", colors(), value=T)   # Colors that have "blue" in the name
points(x=1:10, y=rep(6, 10), pch=19, cex=3, col="557799") # a generic function for drawing
# RRGGBB where each of the pairs RR, GG, BB consist of two hexadecimal digits giving a value in the range 00 to FF
points(x=1:10, y=rep(4, 10), pch=19, cex=3, col=rgb(.25, .5, .3))
#You may notice that RGB here ranges from 0 to 1. While this is the R default, you can also set it for to the 0-255 range using something like rgb(10, 100, 100, maxColorValue=255).

# We can set the opacity/transparency of an element using the parameter alpha (range 0-1):
plot(x=1:5, y=rep(5,5), pch=19, cex=12, col=rgb(.25, .5, .3, alpha=.7), xlim=c(0,6))  

#In many cases, we need a number of contrasting colors, or multiple shades of a color. R comes with some predefined palette function that can generate those for us. For example:
```
# 1. "igraph" Package
```{r installation}
## installing packages:

#install.packages("igraph")
rm(list = ls()) # Remove all the objects we created so far.
library(igraph)
```
## Create networks
The following code generates an undirected graph with four edges. The numbers indicate vertex IDs, so the edges are 1–>2, 2–>3, 3–>1, 4->3.
```{r }
g1 <- graph( edges=c(1,2, 2,3, 3,1, 4,3), n=4, directed=F ) 
class(g1)
plot(g1) # A simple plot of the network - we'll talk more about plots later

# Now with 8 vertices, and directed by default:
g2 <- graph( edges=c(1,2, 2,3, 3,1), n=8 )
plot(g2)  
```

```{r named graphs}
g3 <- graph( c("Ali", "Reza", "Reza", "Hasan", "Hasan", "Ali")) # named vertices
# When the edge list has vertex names, the number of nodes is not needed
plot(g3)

g4 <- graph( c("Ali", "Reza", "Reza", "Hasan", "Reza", "Hasan", "Ali", "Ali"), isolates=c("Farid", "Fatemeh", "Zahra", "Sadegh") )  

# In named graphs we can specify isolates by providing a list of their names.

plot(g4, edge.arrow.size=.5, vertex.color="gold", vertex.size=15, 

     vertex.frame.color="gray", vertex.label.color="black", 

     vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.2) 
```

#Small graphs can also be generated by using symbols + and -:
#- for undirected tie, +- or -+ for directed ties pointing left & right, ++ for a symmetric tie, and “:” for sets of vertices.
```{R}
plot(graph_from_literal(a-b, b---c)) # the number of dashes doesn't matter
plot(graph_from_literal(a--+b, b+--c))
plot(graph_from_literal(a+-+b, b+-+c)) 
plot(graph_from_literal(a: b: c---c: d: e))
plot(graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f :i, j))
```
## Edge, vertex, and network attributes
Access vertices and edges:

```{r Edge-Vertex}
E(g4) # The edges of the object
V(g4) # The vertices of the object
g4[]  # Adjcency Matrix
g4[1,] 

```

### Add attributes to the network, vertices, or edges:

*Vertices and Edges attributes*: The weight attribute is treated in a special way for vertices and edges and can affect the result of some calculations, such as path lengths and centrality measures.

```{r Attribute}
vertex_attr(g4)
V(g4)$name # automatically generated when we created the network.
V(g4)$gender <- c("male", "male", "male", "male", "female", "female", "male")
vertex_attr(g4)

edge_attr(g4)
E(g4)$type <- c("email","classmate","colleague","email") # Edge attribute
E(g4)$weight <- c(10,5,4,2)    # Edge weight, setting all existing edges to 10
edge_attr(g4)  #Examine attributes:

graph_attr(g4)
# Another way to set attributes (you can similarly use set_edge_attr(), set_vertex_attr(), etc.):
g4 <- set_graph_attr(g4,name= "name",value= "facebook Network")
graph_attr(g4, "name")
g4 <- set_graph_attr(g4, "ID", "connections")
g4
g4 <- set_graph_attr(g4, "something", "A thing")
graph_attr(g4)
g4 <- delete_graph_attr(g4, "something")
plot(g4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
     vertex.color=c( "pink", "skyblue")[1+(V(g4)$gender=="male")] ) 

#The graph g4 has two edges going from Jim to Jack, and a loop from John to himself. We can simplify our graph to remove loops & multiple edges between the same nodes. Use edge.attr.comb to indicate how edge attributes are to be combined - possible options include sum, mean, prod (product), min, max, first/last (selects the first/last edge’s attribute). Option “ignore” says the attribute should be disregarded and dropped.

g4s <- simplify( g4, remove.multiple = T, remove.loops = F,         
                 edge.attr.comb=c(weight="sum", type="ignore") )

plot(g4s, vertex.label.dist=1.5)

g4s

```
## #The description of an igraph object starts with up to four letters:

#D or U, for a directed or undirected graph
N for a named graph (where nodes have a name attribute)
W for a weighted graph (where edges have a weight attribute)
B for a bipartite (two-mode) graph (where nodes have a type attribute)
The two numbers that follow (7 5) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:

(g/c) - graph-level character attribute
(v/c) - vertex-level character attribute
(e/n) - edge-level numeric attribute



## 2.3 Special graphs

### Empty graph
```{R}
eg <- make_empty_graph(40)
plot(eg, vertex.size=10, vertex.label=NA)

```
### Full graph






## *Sequences*: "V()" for vertices and "E()" for edges are the sequence functions, allow selections and access to attributes. They return special "igraph.vs" and "igraph.es" objects that can be reused.
```{r}
#install.packages("igraphdata")
library(igraphdata)
data("USairports")
class(USairports)
USairports
graph_attr(USairports)
```

*Vertex attributes*:

```{r}

vertex_attr_names(USairports)

head(vertex_attr(USairports, "City"))

```

*Edges attributes*: The weight attribute is treated in a special way for edges and can affect the result of some calculations, such as path lengths and centrality measures.

```{r}

head(edge_attr_names(USairports))

head(edge_attr(USairports, "Carrier"))

```

*Sequences*: "V()" for vertices and "E()" for edges are the sequence functions, allow selections and access to attributes. They return special "igraph.vs" and "igraph.es" objects that can be reused.

```{r}

V(USairports)[1:5] # Subset by index

V(USairports)["JFK"] # Subset by name

```

Access all attributes of a vertex with double square brackets:

```{r}

V(USairports)[["JFK"]] # All attributes

```

*Adding Attributes*: The dollar sign allows us to manipulate attributes much like a list.

```{r}

V(USairports)[1:5]$City # Access attributes

# Add new attributes
V(USairports)$Group <- sample(c("A","B"), vcount(USairports), replace=TRUE)

V(USairports)[[1:5]] # Double square brackets give all attributes

```

*Edge Selectors*: We can also access edges between named vertices using the special operators:

E(network)[X %--% Y] selects edges between vertex sets X and Y, ignoring direction
E(network)[X %->% Y] selects edges from vertex sets X to vertex set Y
E(network)[X %<-% Y] selects edges from vertex sets Y to vertex set X

```{r}

E(USairports)["JFK" %--% "BOS"] # Edges in both directions
E(USairports)["JFK" %->% "BOS"] # Edges in one direction
E(USairports)["JFK" %<-% "BOS"] # Edges in another direction

```

All Carriers from JFK to BOS.

```{r}

unique(E(USairports)["JFK" %->% "BOS"]$Carrier) # Directed edges

```

*Edges Between Groups*: The edge selectors can be used between groups of vertices:

```{r}
txt <- c("arm","foot","lefroo", "bafoobar")
grep("foo", txt)
grepl("foo",txt)
# Grep the state code from the city
inCal <- grepl("CA$", V(USairports)$City)

inNy <- grepl("NY$", V(USairports)$City)

# Edges from CA to NY
E(USairports)[V(USairports)[inCal] %->% V(USairports)[inNy]]

# Returns all flights from California to New York (state).

```

*Induced subgraph*: To get a new graph containing the selected vertices we must also copy over all of the edges between those vertices. This is done by the "induced_subgraph" function.

```{r}

# inCal has the vertex ids we want
calAirports <- induced_subgraph(USairports, inCal)

calAirports

```

*Neighbourhoods*: A common task is to subset all of the neighbours of a particular vertex. To return all neighbours within
a distance, d, of a number of targets.

```{r}

d2Vertices <- ego(USairports, nodes = "JFK", order=2)
d2Vertices
```

Which returns a list containing the vertices within 2 of JFK . 
If we want the neighbourhood of a vertex as a new graph we can do

```{r}

JFKNet <- make_ego_graph(USairports, nodes = "JFK", order=2)
JFKNet

```

*Adding*: The edges and vertices functions can be used to add edges and nodes.

```{r}

# A directed completely empty graph
g <- make_empty_graph(n = 0, directed = TRUE)
g <- g + vertices(c("A","B","C"))
plot(g)
```

```{r}

g <- g + edges(c("A","C", "B","C")) # edge from A to C and "B" to "C"
plot(g)
```

*Deleting*: For deletion it is easy to use edge and vertex selectors.
Note this will remove all attached edges. All edge and vertex subsetting can be used here.

```{r}

g <- g - V(g)["A"] # Remove node A
plot(g)
```


Now, we want to check some network attributes of a graph that is made by ourselves.
In order to view vertices and edges:

```{r}

E(g4) # The edges

V(g4) # The vertices

```

Directly examining the network:

```{r}

g4[ ]

g4[,1] 

```

For adding attributes to the network, vertices, or edges:

```{r}

V(g4)$name # automatically generated when we created the network.

V(g4)$gender <- c("male", "male", "male", "female", "male", "male", "female")
vertex.attributes (gr4)

E(gr4)$type <- "facebook" # Edge attribute, assign "facebook" to all edges

E(gr4)$weight <- 20    # Edge weight, setting all existing edges to 10
edge.attributes(gr4)

```

Set attributes to graph object:

```{r}

gr4 <- set_graph_attr(gr4,name= "name",value= "facebook Network")

gr4 <- set_graph_attr(gr4, "ID", "connections")
gr4

```

**How to specify graphical parameters?**


There are three ways to give values to the parameters described below, in section 'Parameters'. We give these three ways here in the order of their precedence.


The first method is to supply named arguments to the plotting commands: plot.igraph, tkplot or rglplot. Parameters for vertices start with prefix 'vertex.', parameters for edges have prefix 'edge.', and global parameters have no prefix. Eg. the color of the vertices can be given via argument vertex.color, whereas edge.color sets the color of the edges. layout gives the layout of the graphs.


The second way is to assign vertex, edge and graph attributes to the graph. These attributes have no prefix, ie. the color of the vertices is taken from the color vertex attribute and the color of the edges from the color edge attribute. The layout of the graph is given by the layout graph attribute. (Always assuming that the corresponding command argument is not present.) Setting vertex and edge attributes are handy if you want to assign a given 'look' to a graph, attributes are saved with the graph is you save it with save or in GraphML format with write_graph, so the graph will have the same look after loading it again.


If a parameter is not given in the command line, and the corresponding vertex/edge/graph attribute is also missing then the general igraph parameters handled by igraph_options are also checked. Vertex parameters have prefix 'vertex.', edge parameters are prefixed with 'edge.', general parameters like layout are prefixed with 'plot'. These parameters are useful if you want all or most of your graphs to have the same look, vertex size, vertex color, etc. Then you don't need to set these at every plotting, and you also don't need to assign vertex/edge attributes to every graph.

List names of the graph attributes:

```{r}

graph_attr_names(gr4)

graph_attr(gr4, "name")

graph_attr(gr4) # Graph attributes of a graph

gr4 <- delete_graph_attr(gr4, "ID") # Delete a graph attribute

graph_attr(gr4)

col=c( "orange", "green")[1+(V(gr4)$gender=="male")]

plot(gr4, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
     
     vertex.color=col) 

```

The graph gr4 has two edges between Siamak to Noah, and loops from Siamak and Mehran to themselves. For simplifying the graph and remove loops & multiple edges between the same nodes, you can use edge.attr.comb to show how edge attributes are to be combined - possible options include ignore, sum, prod, min, max, random, first, last, mean, Coursesn, concat. 

The following combination behaviors are predefined:

list("ignore")
The attribute is ignored and dropped.

list("sum")
The sum of the attributes is calculated. This does not work for character attributes and works for complex attributes only if they have a sum generic defined. (E.g. it works for sparse matrices from the Matrix package, because they have a sum method.)

list("prod")
The product of the attributes is calculated. This does not work for character attributes and works for complex attributes only if they have a prod function defined.

list("min")
The minimum of the attributes is calculated and returned. For character and complex attributes the standard R min function is used.

list("max")
The maximum of the attributes is calculated and returned. For character and complex attributes the standard R max function is used.

list("random")
Chooses one of the supplied attribute values, uniformly randomly. For character and complex attributes this is implemented by calling sample.

list("first")
Always chooses the first attribute value. It is implemented by calling the head function.

list("last")
Always chooses the last attribute value. It is implemented by calling the tail function.

list("mean")
The mean of the attributes is calculated and returned. For character and complex attributes this simply calls the mean function.

list("Coursesn")
The Coursesn of the attributes is selected. Calls the R Coursesn function for all attribute types.

list("concat")
Concatenate the attributes, using the c function. This results almost always a complex attribute.

For instance, you can specify that the weight of the new edge should be sum of the weights of the corresponding edges in the old graph; and that the rest of the attributes should be ignored (=dropped).


```{r}

gr4s <- simplify( gr4, remove.multiple = T, remove.loops = T, 
                 edge.attr.comb=c(weight="sum", type="ignore") )

plot(gr4s, vertex.label.dist=1.5)

gr4s

```

# 5. Special Types of Graphs (Standard Structures)

In this section, we are going to learn how to viasulize some well known graph structures:

"make_graph" knows the following graphs:

*Bull*
The bull graph, 5 vertices, 5 edges, resembles to the head of a bull if drawn properly.

*Chvatal*
This is the smallest triangle-free graph that is both 4-chromatic and 4-regular. According to the Grunbaum conjecture there exists an m-regular, m-chromatic graph with n vertices for every m>1 and n>2. The Chvatal graph is an example for m=4 and n=12. It has 24 edges.

*Coxeter*
A non-Hamiltonian cubic symmetric graph with 28 vertices and 42 edges.

*Cubical*
The Platonic graph of the cube. A convex regular polyhedron with 8 vertices and 12 edges.

*Diamond*
A graph with 4 vertices and 5 edges, resembles to a schematic diamond if drawn properly.

*Dodecahedral, Dodecahedron*
Another Platonic solid with 20 vertices and 30 edges.

*Folkman*
The semisymmetric graph with minimum number of vertices, 20 and 40 edges. A semisymmetric graph is regular, edge transitive and not vertex transitive.

*Franklin*
This is a graph whose embedding to the Klein bottle can be colored with six colors, it is a counterexample to the neccessity of the Heawood conjecture on a Klein bottle. It has 12 vertices and 18 edges.

*Frucht*
The Frucht Graph is the smallest cubical graph whose automorphism group consists only of the identity element. It has 12 vertices and 18 edges.

*Grotzsch*
The Groetzsch graph is a triangle-free graph with 11 vertices, 20 edges, and chromatic number 4. It is named after German mathematician Herbert Groetzsch, and its existence demonstrates that the assumption of planarity is necessary in Groetzsch's theorem that every triangle-free planar graph is 3-colorable.

*Heawood*
The Heawood graph is an undirected graph with 14 vertices and 21 edges. The graph is cubic, and all cycles in the graph have six or more edges. Every smaller cubic graph has shorter cycles, so this graph is the 6-cage, the smallest cubic graph of girth 6.

*Herschel*
The Herschel graph is the smallest nonhamiltonian polyhedral graph. It is the unique such graph on 11 nodes, and has 18 edges.

*House*
The house graph is a 5-vertex, 6-edge graph, the schematic draw of a house if drawn properly, basicly a triangle of the top of a square.

*HouseX*
The same as the house graph with an X in the square. 5 vertices and 8 edges.

*Icosahedral, Icosahedron*
A Platonic solid with 12 vertices and 30 edges.

*Krackhardt kite*
A social network with 10 vertices and 18 edges. Krackhardt, D. Assessing the Political Landscape: Structure, Cognition, and Power in Organizations. Admin. Sci. Quart. 35, 342-369, 1990.

*Levi*
The graph is a 4-arc transitive cubic graph, it has 30 vertices and 45 edges.

*McGee*
The McGee graph is the unique 3-regular 7-cage graph, it has 24 vertices and 36 edges.

*Meredith*
The Meredith graph is a quartic graph on 70 nodes and 140 edges that is a counterexample to the conjecture that every 4-regular 4-connected graph is Hamiltonian.

*Noperfectmatching*
A connected graph with 16 vertices and 27 edges containing no perfect matching. A matching in a graph is a set of pairwise non-adjacent edges; that is, no two edges share a common vertex. A perfect matching is a matching which covers all vertices of the graph.

*Nonline*
A graph whose connected components are the 9 graphs whose presence as a vertex-induced subgraph in a graph makes a nonline graph. It has 50 vertices and 72 edges.

*Octahedral, Octahedron*
Platonic solid with 6 vertices and 12 edges.

*Petersen*
A 3-regular graph with 10 vertices and 15 edges. It is the smallest hypohamiltonian graph, ie. it is non-hamiltonian but removing any single vertex from it makes it Hamiltonian.

*Robertson*
The unique (4,5)-cage graph, ie. a 4-regular graph of girth 5. It has 19 vertices and 38 edges.

*Smallestcyclicgroup*
A smallest nontrivial graph whose automorphism group is cyclic. It has 9 vertices and 15 edges.

*Tetrahedral, Tetrahedron*
Platonic solid with 4 vertices and 6 edges.

*Thomassen*
The smallest hypotraceable graph, on 34 vertices and 52 edges. A hypotracable graph does not contain a Hamiltonian path but after removing any single vertex from it the remainder always contains a Hamiltonian path. A graph containing a Hamiltonian path is called tracable.

*Tutte*
Tait's Hamiltonian graph conjecture states that every 3-connected 3-regular planar graph is Hamiltonian. This graph is a counterexample. It has 46 vertices and 69 edges.

*Uniquely3colorable*
Returns a 12-vertex, triangle-free graph with chromatic number 3 that is uniquely 3-colorable.

*Walther*
An identity graph with 25 vertices and 31 edges. An identity graph has a single graph automorphism, the trivial one.

*Zachary*
Social network of friendships between 34 members of a karate club at a US university in the 1970s. See W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977).

*Simple graph*

The "make_graph" function comparing with "graph_literal" is a new function, which can be do the "graph_literal" process too.

"~" is a sign of path in make_graph function.

```{r}

gr1 <- make_graph(~ 1-2-3-4-6,1-5-4-6, 2-5)

plot(gr1)

gr2 <- make_graph( ~ A-B-C-D-A, E-A:B:C:D,
                      F-G-H-I-F, J-F:G:H:I,
                      K-L-M-N-K, O-K:L:M:N,
                      P-Q-R-S-P, T-P:Q:R:S,
                      B-F, E-J, C-I, L-T, O-T, M-S,
                      C-P, C-L, I-L, I-P)
plot(gr2)

```

*Multigraph or pseudograph*

```{r}

muliti.gr <- graph( c("A", "A", "A", "B", "C", "B", "C","B", "C",
                      
                     "D","C","E","C","D","E","D","E","B","E","B","E"
                     ,"B","E","B","E", "A","A"),
        directed=F )  

plot(muliti.gr)

# Find the multiple or loop edges in a graph
which_multiple(muliti.gr)

```

If you wanted to use "graph" function to create a weighted graph, you can give the edgelist as a dataframe which has three columns, first two columns illustrates each edge and the third column specifies their weights.


*Directed Graph (digraph)*

```{r}

directed.gr <- graph( c("A", "A", "A", "B", "C", "B", "C","B", "C",
                        
                       "D","C","E","C","D","E","D","E","B","E","B",
                       
                       "E","B","E","B","E", "A", "A"),directed=T )  

plot(directed.gr)

```

*Weighted graph*

```{r}

df <- read.table(row.names=1, header=TRUE, text=
                    
                  "           A          B          C          D           E         F
                A 0.00000000  0.0000000  0.0000000  0.0000000  0.05119703 1.3431599
                B 0.00000000  0.0000000 -0.6088082  0.4016954  0.00000000 0.6132168
                C 0.00000000 -0.6088082  0.0000000  0.0000000 -0.63295415 0.0000000
                D 0.00000000  0.4016954  0.0000000  0.0000000 -0.29831267 0.0000000
                E 0.05119703  0.0000000 -0.6329541 -0.2983127  0.00000000 0.1562458
                F 1.34315990  0.6132168  0.0000000  0.0000000  0.15624584 0.0000000")

mat <- as.matrix(mat)

# Creating igraph graphs from adjacency matrices
weighted.gr <- graph.adjacency(mat, mode="undirected", weighted=TRUE)

plot(weighted.gr, edge.label=round(E(weighted.gr)$weight, digits= 2))

```

*Empty graph*

```{r}

empty.gr <- make_empty_graph(50)

plot(empty.gr, vertex.size=10, vertex.label=NA)

```

*Full graph*

```{r}

full.gr <- make_full_graph(6)

plot(full.gr, vertex.size=10, vertex.label=NA)

```

*Simple star graph*

```{r}

star.gr <- make_star(50, mode= "out")

plot(star.gr, vertex.size=10, vertex.label=NA) 

```

*Tree graph*

```{r}

tree.gr <- make_tree(24, children = 2, mode = "undirected")

plot(tree.gr, vertex.size=15, vertex.label=NA) 

```

*Paths tree*

```{r}

paths.tree.gr<-make_tree(5, 1, mode = "undirected")

plot(paths.tree.gr)

```

*Stars tree*

```{r}

stars.tree.gr<- graph( c("2", "1", "2", "4", "2", "3", "2","5"),directed=T)  

plot(stars.tree.gr)

```

*Ring graph*

```{r}

ring.g <- make_ring(15,directed = T)

plot(ring.g, vertex.size=10, vertex.label=NA)

```

*Bipartite Graph*

```{r}

# generate random bipartite graph.
bipart.gr <- sample_bipartite(10, 5, p=.4)

# check the type attribute:
V(bipart.gr)$type

# define color and shape mappings.
col <- c("lawngreen", "khaki2")
shape <- c("circle", "rectangle")

plot(bipart.gr,
     
     vertex.color = col[V(bipart.gr)$type+1],
     
     vertex.shape = shape[V(bipart.gr)$type+1]
)

```

*Erdos-Renyi random model*

A random graph is the simplest of the graph models.

```{r}

set.seed(123)
# n = number of nodes, m = the number of edges
erdos.gr <- sample_gnm(n=100, m=200) 

plot(erdos.gr, vertex.size=5, vertex.label=NA) 

```

Here, every edge exists with the probability value, and we only fix the average number of edges (the density).

```{r}

set.seed(10)

gr <- sample_gnp(10, p=0.2) # Generate Erdos-Renyi model
gr

```

*Watts-Strogatz small-world model*

Creates a lattice (with dim=dimensions and size=nodes across dimension) and rewires edges randomly with probability p. The neighborhood in which edges are connected= nei. You can allow loops and multiple edges.

```{r}

set.seed(123)

Watts.gr <- sample_smallworld(dim=2, size=10, nei=1, p=0.1)

plot(Watts.gr, vertex.size=6, vertex.label=NA)

```

*Barabasi-Albert model*

An example of scale-free graphs:

```{r}

set.seed(123)

# n : number of nodes, power : the power of attachment (1 is linear), m : the number of 
# edges added on each time step
barabasi.gr <-  sample_pa(n=100, power=1, m=1,  directed=F)

plot(barabasi.gr, vertex.size=5, vertex.label=NA)

```

*Zachary carate club*

As an example of historical graphs:

```{r}

zach <- graph("Zachary") 

plot(zach, vertex.size=15, vertex.label=NA)

```

*Rewiring a graph*

```{r}

# each_edge : It is a rewiring method that changes the edge endpoints uniformly
# randomly with a probability prob.
zach.rewired <- rewire(zach, each_edge(prob=0.2))

plot(zach.rewired, vertex.size=15, vertex.label=NA)

```
Connect vertices to other vertices at a certain distance.
This function finds the vertices not farther than a given limit from another fixed vertex= neighborhood order=order of the neighborhood

```{r}
# Order smaller than two, graph will be unchanged
erdos.g.neigh = connect.neighborhood(zach, order=2)

plot(erdos.g.neigh, vertex.size=15, vertex.label=NA) 

```

Combine graphs (disjoint union, assuming separate vertex sets): %du%

```{r}

plot(gr1, vertex.size=10) 
plot(tree.gr, vertex.size=10)

du=disjoint_union(tree.gr,gr1)
u=union(tree.gr,gr1)
m=difference(tree.gr,gr1)
s=intersection(tree.gr,gr1)

plot(du, vertex.size=10) 
plot(u, vertex.size=10, vertex.label= V(u)) 
plot(m, vertex.size=10, vertex.label= V(m)) 
plot(s, vertex.size=10, vertex.label= V(s)) 
```

# 6. Import/Export : 

igraph allows import and export from a number of common formats. This is done using the "read_graph" and "write_graph" functions. A common open format is graphml. Other usual formats are as below:

edgelist: A simple text file with one edge per line
pajek: Pajek is a popular Windows program for network analysis
gml: Graph Modelling Language is a common text based open format
graphml: Graph Markup Language is an XML based open format
dot: Format used by GraphViz
ncol: It is a simple symbolic weighted edge list

*graph_from_adjacency_matrix()*: A flexible function for creating igraph graphs from adjacency matrices.

*graph_from_adj_list()*: An adjacency list is a list of numeric vectors, containing the neighbor vertices for each vertex. This function creates an igraph graph object.

*graph_from_data_frame()*: This function creates an igraph graph from one or two data frames containing the (symbolic) edge list and edge/vertex attributes.

*graph_from_edgelist()*:This creates a graph from an edge list. Its argument is a two-column matrix, each row defines one edge. If it is a numeric matrix then its elements are interpreted as vertex ids. If it is a character matrix then it is interpreted as symbolic vertex names and a vertex id will be assigned to each name, and also a name vertex attribute will be added.

*graph_from_incidence_matrix()*: A function for creating a bipartite igraph graph from an incidence matrix.

*graph_from_atlas()*: creates graphs from the book 'An Atlas of Graphs' by Roland C. Read and Robin J. Wilson. The atlas contains all undirected graphs with up to seven vertices, numbered from 0 up to 1252. The graphs are listed:

1. in increasing order of number of nodes;

2. for a fixed number of nodes, in increasing order of the number of edges;

3. fixed numbers of nodes and edges, in increasing order of the degree sequence, for example 111223 < 112222;

4. for fixed degree sequence, in increasing number of automorphisms.

*graph_from_graphdb()*: This function downloads a graph from a database created for the evaluation of graph isomorphism testing algothitms.

*graph_from_graphnel()*: The graphNEL class is defined in the graph package, it is another way to represent graphs. graph_from_graphnel takes a graphNEL graph and converts it to an igraph graph. It handles all graph/vertex/edge attributes. If the graphNEL graph has a vertex attribute called 'name' it will be used as igraph vertex attribute 'name' and the graphNEL vertex names will be ignored.

*graph_from_isomorphism_class()*: The isomorphism class is a non-negative integer number. Graphs (with the same number of vertices) having the same isomorphism class are isomorphic and isomorphic graphs always have the same isomorphism class. Currently it can handle only graphs with 3 or 4 vertices.

*graph_from_lcf()*: LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for 3-regular Hamiltonian graphs. It constists of three parameters, the number of vertices in the graph, a list of shifts giving additional edges to a cycle backbone and another integer giving how many times the shifts should be performed. 

*graph_from_literal()*: Useful to create small graphs via a simple interface.

*read.graph()*: This function is able to read graphs in various representations from a file, or from a http connection. Currently some simple formats are supported (edgelist, pajek, graphml, gml, ncol, lgl, dimacs and graphdb).

*make_ *: This is is generic function for creating graphs i.e. bipartite, chordal ring, directed, ego.


**Reading samples of network data from files**

Converting to a adjacency matrix:

```{r}
# Create ajacency matrix
Adj <- as_adjacency_matrix(gr2, sparse = FALSE)
Adj

gr <- graph_from_adjacency_matrix(Adj)
gr
```

Converting to an edge List:

```{r}

edgelist <- as_edgelist(gr)
edgelist

gr <- graph_from_edgelist(edgelist, directed=TRUE)
gr
```

```{r}

# Create data frame
df <- as.data.frame(edgelist)
df

gr <- graph_from_data_frame(edgelist, directed=TRUE)
gr

```
In the following sections, we try to analyze global and local network properties based on six sample graphs which differ in their structure. 

The first dataset is a representation of directed and weighted network. It is a network of interactions among cortical regions in the Rhesus brain, via a retrograde tracer study.

Network summary:

Edge Type: Interaction

Node Type: Anatomical region

Avg Edges: 628.00

Avg Nodes: 91.00

Graph properties: Directed, Weighted


```{r}

# first sample network
net1<-read.graph("rhesus_brain_2.graphml", format = "graphml")
net1

```

The second one is a bipartite network of birds and plants, from a forest on Mount Missim, in Papua New Guinea, collected between July 1978 to November 1980. Edge weights represent the frequency of interaction between a bird and a plant. Two-mode or bipartite graph has two different types of birds and plants that go across, but not within each type. The authors recorded their data by counting the number of visits of each bird species to each plant species. Data are presented as an interaction frequency matrix, in which cells with positive integers indicate the frequency of interaction between a pair of species, and cells with zeros indicate no interaction.

Network summary:

Edge Type: Interaction

Node Type: Species

Avg Edges: 119.00

Avg Nodes: 40.00

Graph properties: Undirected, Weighted, Bipartite

```{r}

# second sample network
data <- read.csv("beehler_1983.txt",sep="\t",header = TRUE)

row.names(data)<-data[,1]

data<-data[,-1]

# Examine data 
head(data)

# Converting to a graph object
net2<-graph_from_incidence_matrix(data, weighted = TRUE)
net2

```

The third dataset is a representation of a directed network contains friendships between boys in a small highschool in Illinois. Each boy was asked once in the fall of 1957 and the spring of 1958. This dataset aggregates the results from both dates. A node represents a boy and an edge between two boys shows that the left boy chose the right boy as a friend. The edge weights show how often that happened. As a boy could choose the same boy twice edge values from 1 to 2 are allowed.

Network summary:

Edge Type: Friendship

Node Type: Boy

Size:	70 vertices (boys)

Volume:	366 edges (friendships)

Graph properties: Directed, Weighted

```{r}

# third sample network
ncol=read.csv("edgelist.Highschool.txt")
head(ncol)
net3<-read.graph("edgelist.Highschool.txt",format="ncol")
net3

```

The fourth one is a bipartite network contains membership information of 136 people in 5 organisations dating back to the time before the American Revolution. The list includes well-known people such as the American activist Paul Revere. Left nodes represent persons and right nodes represent organisations. An edge between a person and an organization shows that the person was a member of the organisation.

Network summary:

Edge Type: Membership

Node Type: Person, organization

Size:	277 = 141 + 136 vertices (persons + organizations)

Volume:	160 edges (memberships)

Graph properties: Undirected, Unweighted, Bipartite

```{r}

# forth sample network
df<-read.table("American Revolution.txt",header = F)
head(df)

net4 <- graph.data.frame(df, directed= FALSE)
net4

# check if is recognized as bipartite
is.bipartite(net4)

V(net4)$type <- V(net4)$name %in% df[,1]

net4
is.bipartite(net4)

```

The fifth dataset expressed a directed weighted network which defines practical and theorical among courses that is taken  by the high school students. 

Network summary:

Edge Type: Common courses

Node Type: students

Size:	20 vertices (students)

Volume:	48 edges (Common courses)

Graph properties: Directed, Weighted

```{r}

# fifth sample network
nodes <- read.table("students via courses.Nodes.txt", header=T, sep="\t")
edge.df <- read.table("students via courses.Edges.txt", header=T,sep ="\t")

# Data visualization
head(nodes)

head(edge.df)

edge.df <- aggregate(edge.df[,3], edge.df[,-3],sum)

edge.df <- edge.df[order(edge.df$from, edge.df$to),]
colnames(edge.df)[4] <- "weights"
rownames(edge.df) <- NULL

net5 <- graph_from_data_frame(d=edge.df, vertices=nodes, directed=T) 
net5

```

The sixth dataset focused on a bipartite network of edges between courses and students.

Network summary:

Edge Type: Common courses

Node Type: students, Courses

Size:	65 = 10 + 21 vertices (Courses + Students)

Volume:	41 edges (Common courses)

Graph properties: Undirected, Unweighted, Bipartite

```{r}

# sixth sample network
nodes6 <- read.table("Courses bipartite.Nodes.txt", header=T, sep="\t")
edges6 <- read.table("Courses bipartite.Edges.txt", header=T, sep="\t", row.names = 1)

# Visualize the data:
head(nodes6)

head(edges6)

# edges2 is an adjacency matrix for a two-mode network:
edges6 <- as.matrix(edges6)

dim(edges6)
dim(nodes6)

net6 <- graph_from_incidence_matrix(edges6)

# define color and shape mappings.
col <- c("lawngreen", "khaki2")
shape <- c("circle", "rectangle")

plot(net6,
     
     vertex.color = col[V(net6)$type+1],
     
     vertex.shape = shape[V(net6)$type+1]
)

```

```{r}

# Network class
class(net5)

net5 

# check if is recognized as directed
is.directed(net5)

# check if is recognized as weighted
is.weighted(net5)

```

Anything after the first two columns are treated as edge attributes.

```{r}

# Edges and vertices
E(net5)
V(net5)
E(net5)$weights
E(net5)$types
V(net5)$Courses 

```

```{r}

as_edgelist(net5, names=T)

as_adjacency_matrix(net5, attr="weights")

# Or data frames describing nodes and edges:

as_data_frame(net5, what="edges")

as_data_frame(net5, what="vertices")

```

```{r}
# Network class
class(net6)

net6

# check if is recognized as directed
is.directed(net6)

# check if is recognized as weighted
is.weighted(net6)

# A built-in vertex attribute 'type' shows which mode vertices belong to.
table(V(net6)$type)

```

In order to project bipartite networks:

```{r}

net6.bp <- bipartite.projection(net6)
net6.bp
```

To manually project the networks, the following formula can be used:

as_incidence_matrix(net6)  %*% t(as_incidence_matrix(net6))
t(as_incidence_matrix(net6)) %*%   as_incidence_matrix(net6)

```{r}

plot(net6.bp$proj1,vertex.label.color="gray30",
     
     vertex.label.cex=0.8, vertex.label.dist=2,
     
     vertex.label=as.character(nodes6$Courses[!is.na(nodes6$Course.type)])
     )

plot(net6.bp$proj2,vertex.label.color=" gray30",
     
     vertex.label.cex=0.8 , vertex.label.dist=2,
     
     vertex.label=as.character(nodes6$Courses[is.na(nodes6$Course.type)])
     )

```

# 7. Network Descriptives

*Density*: The ratio of the number of edges and the number of possible edges.

```{r}

edge_density(net5, loops=F)

ecount(net5)/(vcount(net5)*(vcount(net5)-1)) #for a directed network

2*ecount(as.undirected(net5))/(vcount(as.undirected(net5))*(vcount(as.undirected(net5))-1)) #for an undirected network

```

*Reciprocity*: The proportion of mutual connections, in a directed graph.

```{r}

reciprocity(net5)

dyad_census(net5) # Mutual, asymmetric, and null node pairs

2*dyad_census(net5)$mut/ecount(net5) # Calculating reciprocity

```

*Transitivity*: Global - ratio of triangles (direction disregarded) to connected triples and local - ratio of triangles to connected triples each vertex is part of.

```{r}

transitivity(net5, type="global")  # network is treated as an undirected network

transitivity(as.undirected(net5, mode="collapse")) # same as above

transitivity(net5, type="local")

triad_census(net5) # for directed networks

```

*Diameter*: The length of the longest geodesic. 

```{r}
# Note that edge weights are used by default, unless set to NA.
diameter(net2, directed=F, weights = NA)

diameter(net2, directed=F)

# To extract the path with the actual diameter.
diam <- get_diameter(net5, directed=T)
diam

# Note: vertex sequences asked to behave as a vector produce numeric index of nodes
class(diam)

as.vector(diam)

```

```{r}

# Color nodes along the diameter:
vcol <- rep("gray", vcount(net5))

vcol[diam] <- "red"

ecol <- rep("gray", ecount(net5))

ecol[E(net5, path=diam)] <- "red" 

# E(net, path=diam) finds edges along a path, here 'diam'
plot(net5, vertex.color=vcol, edge.color=ecol, edge.arrow.mode=1, edge.curved= 0.2)

```

*Node degrees*: The  most basic structural property, the number of its adjacent edges.
'degree' has a mode of 'in' for in-degree, 'out' for out-degree, and 'all' or 'total' for total degree.

```{r}

deg <- degree(net5,mode = "all")

plot(net5, vertex.size=deg*3)

hist(deg, breaks=1:vcount(net5)-1, main="Histogram of nodes degree",col = "purple")

# Erdos-Reney
hist(scale(degree(erdos.gr)), breaks=-3:4, main="Histogram of nodes degree",col = "darkgreen")
# Watts-Strogatz
hist(scale(degree(Watts.gr)), breaks=seq(-3,4,1), main="Histogram of nodes degree",col = "green")
# Barabasi-Albert
hist(scale(degree(barabasi.gr)), breaks=seq(-2,8,1), main="Histogram of nodes degree",col = "turquoise")

```

*Degree distribution*

```{r}

deg.dist <- degree_distribution(net5, cumulative=T, mode="all")

plot(x=0:max(deg), y=1-deg.dist, pch=19, cex=1.5, col="purple", 
      
      xlab="Degree", ylab="Cumulative Frequency")

# Erdos-Reney
plot(x=0:max(degree(erdos.gr)), 
     
     y=1-degree_distribution(erdos.gr, cumulative=T, mode="all"), 
     
     pch=19, cex=1.5, col="darkgreen",  
     
     xlab="Degree", ylab="Cumulative Frequency")

# Watts-Strogatz
plot(x=0:max(degree(Watts.gr)), 
     
     y=1-degree_distribution(Watts.gr, cumulative=T, mode="all"), 
     
     pch=19, cex=1.5, col="green",  
     
     xlab="Degree", ylab="Cumulative Frequency")

# Barabasi-Albert
plot(x=0:max(degree(barabasi.gr)), 
     
     y=1-degree_distribution(barabasi.gr, cumulative=T, mode="all"), 
     
     pch=19, cex=1.5, col="turquoise",  
     
     xlab="Degree", ylab="Cumulative Frequency")
```

# 8. Centrality and Distances

**Centrality & centralization**
Degree is the simplest centrality measure. Many other measures exist to assess which vertices are the most important one in some way. The measure you choose depends on what function of the network you are interested in. Here we will cover some of the most popular measures.

In another function, we introduce centrilization which is a method for creating a graph level centralization measure from the centrality scores of the vertices.

```{r}

# Degree (number of ties)
degree(net5, mode="all")

centr_degree(net5, mode="all", normalized=TRUE)

```

*Closeness*: Inverse of the node's average geodesic distance to others in the network. 

```{r}

closeness(net5, mode="all", weights=NA) 

centr_clo(net5, mode="all", normalized=T) 

```

*Eigenvector*: The Eigenvector gives a high score to vertices that either have a lot of connections, or are connected to someone with a lot of connections.

Attention: Eigenvector centrality may be used in directed networks, but in principle, there are left and right eigenvectors to choose from. Some caution is required here.

```{r}

eigen.cent<-eigen_centrality(net5, directed=T, weights=NA)

eigen.cent$vector

#or
centr_eigen(net5, directed=T, normalized=T) 

```

*Betweenness*: Betweeness centrality is based on the distances between vertices. It is the number of geodesic paths that pass through any given node. Vertices with a high betweenness score will often act as bridging nodes between one or more communities.

Attention: Betweeness can be expensive to calculate. Try "estimate_betweeness" if betweeness is slow.

```{r}

betweenness(net5, directed=T, weights=NA)

edge_betweenness(net5, directed=T, weights=NA)

centr_betw(net5, directed=T, normalized=T)

```

*Hubs and authorities*: The hubs and authorities algorithm developed by Jon Kleinberg was initially used to examine web pages. Hubs were expected to contain catalogues with a large number of outgoing links; while authorities would get many incoming links from hubs, presumably because of their high-quality relevant information.

```{r}

hs <- hub_score(net5, weights=NA)$vector

as <- authority_score(net5, weights=NA)$vector

# Course type coloring
colrs <- c("gold", "dark red", "dark blue","dark green")

V(net5)$color <- colrs[V(net5)$Course.type]

# Plot
# Here, we consider net5 as undirected network.
 par(mfrow=c(1,2))

 plot(as.undirected(net5), vertex.size=hs*50, vertex.label.dist=3, main="Hubs")
 
 plot(as.undirected(net5), vertex.size=as*30, vertex.label.dist=3, main="Authorities")

```

*PageRank Centrality*: PageRank is the centrality measure used by Google to rank web pages. In fact, 'Page' refers to Larry Page not a web page.

```{r}

pr <- page_rank(net5)
pr$vector

```

**Distances and paths**

*Average path length*: The mean of the shortest distance between each pair of nodes in the network (in both directions for directed graphs).

```{r}

mean_distance(net5, directed=F)

mean_distance(net5, directed=T)

```

You can also find the length of all shortest paths in the graph:

```{r}

head(distances(net3)) # with edge weights

head(distances(net3, weights=NA)) # ignore weights

```

We can extract the distances to a node or set of nodes which are interesting for us.


```{r}

dist.Business <- distances(net5, v=V(net5)[Courses =="Business law"],
                           
                           to=V(net5), weights=NA)

dist.Business

```

"colorRampPalette": This function returns functions that interpolate a set of given colors to create new color palettes

```{r}

# Set colors to plot the distances:
col.spect <- colorRampPalette(c("dark blue", "yellow"))

col <- col.spect(max(dist.Business)+1)
col

col.node <- col[dist.Business+1]
col.node

plot(as.undirected(net5), vertex.color=col.node, vertex.label=V(net5), edge.arrow.size=.7, 
     
     vertex.label.color="black")

```

We can also find the shortest path between specific nodes. 

```{r}

Courses.path <- shortest_paths(net5, 
                               
                            from = V(net5)[Courses=="Animation"], 
                            
                             to  = V(net5)[Courses=="Home economics"],
                            
                             output = "both") # both path nodes and edges
Courses.path$epath

```

```{r}

# Generate edge color variable to plot the path:
ecol <- rep("gray80", ecount(net5))

ecol[unlist(Courses.path$epath)] <- "orange"

# Generate edge width variable to plot the path:
ew <- rep(2, ecount(net5))

ew[unlist(Courses.path$epath)] <- 4

# Generate node color variable to plot the path:
vcol <- rep("gray40", vcount(net5))

vcol[unlist(Courses.path$vpath)] <- "gold"

plot(net5, vertex.color=vcol, edge.color=ecol, 
     
     edge.width=ew)

```

Identify the edges going into or out of a vertex, for instance "Home economics".
For a single node, use 'incident()', for multiple nodes use 'incident_edges()'

```{r}

incid.edges <- incident(net5, V(net5)[Courses=="Home economics"], mode="all")
str(incid.edges)

```

```{r}

# Set colors to plot the selected edges.
ecol <- rep("gray80", ecount(net5))

ecol[incid.edges] <- "orange"

vcol <- rep("grey40", vcount(net5))

vcol[V(net5)$Courses=="Home economics"] <- "gold"

plot(net5, vertex.color=vcol, edge.color=ecol)

```

We can also easily identify the neighbors of a vertex, for instance "Home economics".
The 'neighbors' function finds all nodes one step out from the specified node.
To find the neighbors for multiple nodes, use 'adjacent_vertices()'.
To find node neighborhoods going more than one step out, use function 'ego()'
with parameter 'order' set to the number of steps out to go from the focal node(s).

```{r}

neigh.nodes <- neighbors(net5, V(net5)[Courses=="Home economics"], mode="all")

# Set colors to plot the neighbors:

vcol[neigh.nodes] <- "#e07511"

plot(net5, vertex.color=vcol)

```

For example, select edges from Computer Science to English sources:

```{r}

E(net5)[ V(net5)[Course.type.label=="Computer Science"] %->%
           
           V(net5)[Course.type.label=="Business"] ]

# Cocitation (for a couple of nodes, how many shared neighbors they have)

cocitation(net5)

```

# 9. Subgraphs and Communities

*Cliques*
A subset of vertices of an undirected graph such that its induced subgraph is complete; that is, every two distinct vertices in the clique are adjacent.

```{r}

cliques(zach, min=4) # list of cliques with minimum 4 nodes       

sapply(cliques(zach), length) # clique sizes

largest_cliques(zach) # cliques with max number of nodes

vcol <- rep("grey80", vcount(zach))

vcol[unlist(largest_cliques(zach))] <- "gold"

plot(zach, vertex.label=V(zach)$name, vertex.color=vcol)

```

*Communities*

A number of algorithms aim to detect groups that consist of densely connected nodes
with fewer connections across groups.

Community detection based on edge betweenness (Newman-Girvan): High-betweenness edges are removed sequentially (recalculating at each step) and the best partitioning of the network is selected.

```{r}

clust.bet <- cluster_edge_betweenness(as.undirected(zach) )
dendPlot(clust.bet, mode="hclust")
plot(clust.bet, as.undirected(zach),vertex.label=NA) 

```

Let's examine the community detection igraph object:

```{r}

class(clust.bet)
length(clust.bet)     # number of communities
membership(clust.bet) # community number of each node
crossing(clust.bet, zach) # boolean vector: TRUE for edges across communities
modularity(clust.bet) # how modular the graph partitioning is

```

High modularity for a partitioning reflects dense connections within communities
and sparse connections across communities.

Community detection based on propagating labels: Assigns node labels, randomizes, and replaces each vertex's label with the label that appears most frequently among neighbors. Repeated until each vertex has the most common label of its neighbors.

```{r}

clust.pr <- cluster_label_prop(zach)
plot(clust.pr, zach)

```

Community detection based on greedy optimization of modularity:

```{r}

com.gr <- cluster_fast_greedy(zach)
plot(com.gr, zach)
 
```

We can also plot the communities without relying on their built-in plot:

```{r}

V(zach)$community <- com.gr$membership

colrs <- adjustcolor( c("gold", "turquoise", "olivedrab", "darkgreen"), alpha=.5)

plot(zach, vertex.color=colrs[V(zach)$community])

```

*K-core decomposition*
The k-core is the maximal subgraph in which every node has degree of at least k if it belongs to the k-core but not to the (k+1)-core. 

```{r}

k.decomp <- coreness(zach, mode="all")
plot(zach, vertex.size=k.decomp*8, vertex.label=k.decomp, vertex.color=colrs[k.decomp])

```

*Assortativity and Homophily*: The assortativity coefficient measures the level of homophyly of the graph, based on some vertex labeling or values assigned to vertices. If the coefficient is high, that means that connected vertices tend to have the same labels or similar assigned values.

```{r}

V(net5)$Course.type.label

V(net5)$Course.type

assortativity_nominal(net5, V(net5)$Course.type, directed=F) # for categorical variables

assortativity(net5, V(net5)$Number.of.teachers, directed=F) # for ordinal variables

assortativity_degree(net5, directed=F)

```


# 10. Statistical Inference

This section involves making statistical models of networks based on the random graph family of network models.

"Statnet" package: It is a suite of network tools from a group of academics mostly at the University of Washington (statnet.org). Each tool is a separate R package that is installed all in one go with statnet. This includes the network package (core features), sna (social network analysis) and ergm (exponential random graphs).

```{r}

# install.packages("statnet")
library(network)

```

Statnet can be a little tricky to use compared to igraph. Here we will look at how to quickly get our data into network objects from files and converting from igraph.

```{r}

edges <- read.table("Dolphin-edges.txt",header = T,sep="\t")

# Read the edge list
net.dolph <-network(edges, matrix.type='edgelist',
                    ignore.eval=FALSE, directed=FALSE)

# Attach the vertex attributes
att.vertex <- read.table("Dolphin-nodes.txt",header = T,sep="\t",stringsAsFactors = F)

# %v% is equivalent to get.vertex.attribute in igraph
net.dolph%v%"Gender" <- att.vertex$Gender

plot(net.dolph)

```

*Convert from igraph*
The intergraph package is a useful shortcut to convert the objects from one package to the other.

```{r}

library(intergraph)

# statnet -> igraph
dolphinIgraph <- asIgraph(net.dolph, vnames="vertex.names")
dolphinIgraph

# igraph -> statnet
data("karate")

karateNet <- asNetwork(karate)
karateNet

```

*Exponential Random Graph Models (ERGMs)*
An exponential random graph extends the simple random graph by increasing the probability of other properties and network motifs, not just the density. We can fit parameters to each motif in a similar way to terms in a GLM.

```{r}

library(ergm)
fit <- ergm(net.dolph ~ edges)

## Evaluating log-likelihood at the estimate.
summary(fit)

# Check it worked
pFit <- exp(fit$coef)/(1+exp(fit$coef))

p <- network.density(net.dolph)

p

pFit

```

*Group Membership*
The first question we might wish to ask is are connections affected by group membership? In the case of
the dolphin network we know the gender of most of the dolphins. Are dolphins of the same gender more likely to be connected?

```{r}

fitGender <- ergm(net.dolph ~ edges + nodematch("Gender"))
summary(fitGender)
```

**Other Model Terms**

edges: Fits the total number of edges
nodematch: Fits the propensity for inter-group edges
nodecov: Nodal covariates, numeric variables that might influence connection
triangles: Total number of triangles, fits more clustered networks. Can have trouble fitting. 
gwesp: Can be more stable than triangles
degree: Degree distribution

See ?"ergm-terms" for a full list of terms.

**Simulation example**

Here, the simulated network misses the community structure but does recreate density and inter-gender
connectivity.

```{r}

dolphinSim <- simulate(fitGender,3)
dolphinSim

op <- par(mfrow=c(2,2), mar=c(0,0,1,0))

plot(net.dolph, vertex.col=c("pink","blue", "white")[factor(net.dolph%v%"Gender")],
     
main="Real Network")

plot(dolphinSim[[1]], vertex.col=c("pink","blue", "white")[factor(net.dolph%v%"Gender")],
     
main="Simulated Network")
plot(dolphinSim[[2]], vertex.col=c("pink","blue", "white")[factor(net.dolph%v%"Gender")],
     
main="Simulated Network")
plot(dolphinSim[[3]], vertex.col=c("pink","blue", "white")[factor(net.dolph%v%"Gender")],
     
main="Simulated Network")

par(op)

```

**Goodness of Fit**
The goodness of fit function, gof will simulated many networks and calculate summary statistics to see
how close the model networks are to your original model. This is very useful to assess the quality of your model. Here we fit degree well (left) but clustering and geodesic distance poorly.

```{r}

gofGender <- gof(fitGender)
gofGender

plot(gofGender)

```

# 11. Graphs Visualization

Plotting in igraph: igraph uses base R plotting methods. Plotting is done through the S3 generic plot function. To find specific help for this function try typing

```{r}

#?plot.igraph
# Or
#?igraph.plotting

```

The igraph plotting parameters include (among others):

**Plotting parameters*
 
 *NODES*:
 
 vertex.color :  Node color
 
 vertex.frame.color :  Node border color
 
 vertex.shape :  One of "none", "circle", "square", "csquare", "rectangle", "crectangle", "vrectangle", "pie", "raster", or "sphere"
 
 vertex.size  : Size of the node (default is 15)
 
 vertex.size2 :  The second size of the node (e.g. for a rectangle)
 
 vertex.label	: Character vector used to label the nodes
 
 vertex.label.family	: Font family of the label (e.g."Times", "Helvetica")
 
 vertex.label.font	: 1 plain, 2 bold, 3 italic, 4 bold italic, 5 symbol
 
 vertex.label.cex	:  Font size (multiplication factor, device-dependent)
 
 vertex.label.dist	: Distance between the label and the vertex
 
 vertex.label.degree	: The position of the label in relation to the vertex, where 0 right, "pi" is left, "pi/2" is below, and "-pi/2" is above
  
 *EDGES*:
 
 edge.color	: Edge color
 
 edge.width	: Edge width, defaults to 1
 
 edge.arrow.size	: Arrow size, defaults to 1
 
 edge.arrow.width	: Arrow width, defaults to 1
 
 edge.lty	: Line type, could be 0 or "blank", 1 or "solid", 2 or "dashed", 3 or "dotted", 4 or "dotdash", 5 or "longdash", 6 or "twodash"
 
 edge.label	: Character vector used to label edges
 
 edge.label.family	: Font family of the label (e.g."Times", "Helvetica")
 
 edge.label.font	: 1 plain, 2 bold, 3 italic, 4 bold italic, 5 symbol
 
 edge.label.cex	: Font size for edge labels
 
 edge.curved	: Edge curvature, range 0-1 (FALSE sets it to 0, TRUE to 0.5)
 
 arrow.mode	: Vector specifying whether edges should have arrows, possible values: 0 no arrow, 1 back, 2 forward, 3 both
  
 *OTHER*:	
 
 margin	: Empty space margins around the plot, vector with length 4 
 
 frame	: If TRUE, the plot will be framed
 
 main	: If set, adds a title to the plot
 
 sub	: If set, adds a subtitle to the plot
 
 
```{r}

plot(net6, edge.arrow.size=.4, edge.curved=.2)

```

Replace the vertex label with the node names stored in "Courses"
 
```{r}

plot(net6, edge.arrow.size=.2, edge.curved=0,
     
     vertex.color="khaki", vertex.frame.color="red",
     
     vertex.label=V(net6)$Courses, vertex.label.color="black",
     
     vertex.label.cex=.7) 

```

The second way to set attributes is to add them to the igraph object. Let's say we want to color our network nodes based on type of Courses,and size them based on teacher size (larger teacher -> larger node).

We will also change the width of the edges based on their weight.


```{r}

# Generate colors based on Courses type
colrs <- c("gold", "dark red", "dark blue","dark green")

V(net5)$color <- colrs[V(net5)$Course.type]

# Set node size based on number of teachers
V(net5)$size <- V(net5)$Number.of.teachers*0.8

# The labels are currently students IDs. Setting them to NA will render no labels
V(net5)$label <- NA

# Change arrow size and edge color
E(net5)$arrow.size <- .4

E(net5)$edge.color <- "gray70"

E(net5)$width <- 1+E(net5)$weight/12

# We can also override the attributes explicitly in the plot
plot(net5) 

```

It helps to add a legend explaining the meaning of the colors we used:

```{r}

plot(net5) 

legend(x=-1.5, y=-1.1, c("Computer Science","Business","English",
                         "Family and Consumer Science"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="o", ncol=1)

```

Sometimes, especially with semantic networks, we may be interested in plotting only the labels of the nodes:

```{r}

plot(net5, vertex.shape="none", vertex.label=V(net5)$Courses,
     vertex.label.font=2, vertex.label.color="gray40",
     vertex.label.cex=.7, edge.color="gray85")

```

Let's color the edges of the graph based on their source node color.
We can get the starting node for each edge with the "ends()" igraph function.

```{r}

edge.start <- ends(net5, es=E(net5), names=F)[,1] # Incident vertices of some graph edges

edge.col <- V(net5)$color[edge.start]

plot(net5, edge.color=edge.col, edge.curved=.1) 

```

**Network layouts** 

They are simply algorithms that return coordinates for each node in a network.

```{r}

net.bg <- sample_pa(80) 

V(net.bg)$size <- 8

V(net.bg)$frame.color <- "white"

V(net.bg)$color <- "orange"

V(net.bg)$label <- "" 

V(net.bg)$shape <- "square"

E(net.bg)$arrow.mode <- 0

plot(net.bg, vertex.shape="square")

```

Set the layout in the plot function:

```{r}

plot(net.bg, layout=layout_randomly)

```

Or you can calculate the vertex coordinates in advance:
l is simply a matrix of x, y coordinates (N x 2) for the N nodes in the graph.
You can easily generate your own:

```{r}

l <- cbind(1:vcount(net.bg), c(seq(1,vcount(net.bg),20),vcount(net.bg):5))

plot(net.bg, layout=l)

```

This layout is just an example and not very helpful, thankfully igraph has a number of built-in layouts, including:

*Randomly placed vertices*: 

This function uniformly randomly places the vertices of the graph in two or three dimensions.

```{r}

l <- layout_randomly(net.bg) 

plot(net.bg, layout=l)

```

*Circle layout*:

```{r}

l <- layout_in_circle(net.bg)

plot(net.bg, layout=l)

```

*3D sphere layout*:

Place vertices on a sphere, approximately uniformly, in the order of their vertex ids.

```{r}

l <- layout_on_sphere(net.bg) 

plot(net.bg, layout=l, vertex.shape="circle")

```

*Tree layout*

For tree-like networks the layout_as_tree layout will try to organise vertices into levels.

```{r}

gTree <- make_tree(15)

plot(gTree, layout=layout_as_tree(gTree, root = 1))

```

*Grid layout*

```{r}

plot(gr, layout=layout_on_grid(gr))

```

**Force Layouts**

The most common layouts for medium or large graphs are force layouts. igraph has a number of this kind of layout.

layout_with_fr : Fruchterman-Reingold layout algorithm. Edge weights correspond to the strength of the springs.

layout_with_kk : Kamada-Kawai layout algorithm. Edge weights correspond to length of springs.

layout_with_drl : The Distributed Recursive(Graph) Layout (DrL) algorithm. Based on the VxOrd package from Sandia labs.

*Fruchterman-Reingold*: 

This is one of the most used force-directed layout algorithms out there.Force-directed layouts try to get a nice-looking graph where edges are similar in length and cross each other as little as possible. They simulate the graph as a physical system. Nodes are electrically charged particles that repulse each other when they get too close. The edges act as springs that attract connected nodes closer together. As a result, nodes are evenly distributed through the chart area, and the layout is intuitive in that nodes which share more connections are closer to each other. The disadvantage of these algorithms is that they are rather slow and therefore less often used in graphs larger than ~1000 vertices. You can set the "weight" parameter which increases the attraction forces among nodes connected by heavier edges.
Place vertices on the plane using the force-directed algorithm by Fruchterman and Reingold.

```{r}

l <- layout_with_fr(net.bg) 

plot(net.bg, layout=l)

```

You will notice that the layout is not deterministic - different runs will result in slightly different configurations. Saving the layout in  l allows us to get the exact same result multiple times, which can be helpful if you want to plot the time evolution of a graph, or different relationships - and want nodes to stay in the same place in multiple plots.

```{r}

par(mfrow=c(2,2), mar=c(0,0,0,0))   # plot four figures - 2 rows, 2 columns

plot(net.bg, layout=layout_with_fr)

plot(net.bg, layout=layout_with_fr)

plot(net.bg, layout=l)

plot(net.bg, layout=l)

```

By default, the coordinates of the plots are rescaled to the [-1,1] interval for both x and y. You can change that with the parameter rescale=FALSE and rescale your plot manually by multiplying the coordinates by a scalar. You can use norm_coords to normalize the plot with the boundaries you want.

```{r}

l <- layout_with_fr(net.bg)

# Rescale coordinates linearly to be within given bounds.
l <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)  


par(mfrow=c(2,2), mar=c(0,0,0,0))

plot(net.bg, rescale=F, layout=l*0.4)

plot(net.bg, rescale=F, layout=l*0.6)

plot(net.bg, rescale=F, layout=l*0.8)

plot(net.bg, rescale=F, layout=l*1.0)

```

*Kamada Kawai layout*: 

Another popular force-directed algorithm that produces nice results for connected graphs is Kamada Kawai. Like Fruchterman Reingold, it attempts to minimize the energy in a spring system. The Kamada-Kawai layout algorithm place the vertices on the plane, or in the 3d space, based on a phyisical model of springs.

```{r}

l <- layout_with_kk(net.bg) 
plot(net.bg, layout=l)

```

*LGL layout*: 

The LGL algorithm is meant for large, connected graphs. Here you can also specify a root: a node that will be placed in the middle of the layout.

```{r}

plot(net.bg, layout=layout_with_lgl)

```

Let's take a look at all available layouts in igraph:

```{r}

# Pattern Matching and Replacement
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1] 

```

Remove layouts that do not apply to our graph.

```{r}

layouts <- layouts[!grepl("bipartite|sugiyama|tree", layouts)]

par(mfrow=c(3,3), mar=c(1,1,1,1))

for (layout in layouts) {
  
  print(layout)
  
  l <- do.call(layout, list(net5)) # Execute a Function Call
  
  plot(net5, edge.arrow.mode=0, layout=l, main=layout) }

```
```{r}

layouts <- layouts[!grepl("bipartite|sugiyama|tree|sphere", layouts)]

par(mfrow=c(3,3), mar=c(1,1,1,1))

for (layout in layouts) {
  
  print(layout)
  
  l <- do.call(layout, list(net.bg)) # Execute a Function Call
  
  plot(net.bg, edge.arrow.mode=0, layout=l, main=layout) }

```

**Vertex Properties**

We can change various aspects of the vertex appearance. For example the shape:

```{r}

# Plot vowels as rectangles
Vowel <- V(gr)$name %in% c("A","E","I","O","U") + 1 # gives 1 or 2

plot(gr,  vertex.shape=c("circle", "square")[Vowel])

```

*Vertex Colours and Size*

```{r}

plot(gr,  vertex.color=c("tomato2", "royalblue")[Vowel])

```

```{r}

plot(gr,  vertex.size=c(15,30)[Vowel])

```

*Properties Using Attributes*

Any of the plotting properties can also be set as attributes of the vertices/edges.

```{r}

V(gr)$shape <- "circle" # Applies to all vertices

V(gr)$size <- 15

V(gr)$color <- "orange"

isVowel <- V(gr)$name %in% c("A","E","I","O","U")

# Now overwrite the vowel nodes
V(gr)[isVowel]$shape <- "square"

V(gr)[isVowel]$color <- "royalblue"

V(gr)[isVowel]$size <- 25

plot(gr, layout=layout_in_circle)
gr
```

*Edge Properties*

```{r}

# Setting edge attributes
E(gr)$width <- 1

E(gr)[V(gr)[isVowel] %--% V(gr)[isVowel]]$width <- 4

plot(gr, layout=layout_in_circle)

```

*Groupings*

```{r}

# Assign groups by index
groupList <- list(vowelGroup = which(isVowel),
constGroup1 = c(2,3,4),
constGroup2 = c(6,7,8))

# Alpha looks nice
groupColours <- c(rgb(0,0.3,1,0.5),
rgb(0.8,0.4,0.1,0.5),
rgb(0.8,0.4,0.1,0.5))
plot(gr, layout=layout_with_fr, # Fruchterman-Reingold layout
mark.groups=groupList, # Mark the groups
mark.col= groupColours,
mark.border = NA, # Remove the border (if desired)
edge.curved=0.1)

text(0.45,0.1,"Vowels", cex=1.2)
text(0.5,1,"Consonant Group 1", cex=0.75)
text(-0.8,-1,"Consonant Group 2", cex=0.75)

```

# 12. Network plot improvement

We can identify the type and size of nodes, but cannot see much about the structure since the links we're examining are so dense. One way to approach this is to see if we can sparsify the network, keeping only the most important ties and discarding the rest.

```{r}

hist(edge.df$weight)

mean(edge.df$weight) 

sd(edge.df$weight) # Standard Deviation

```

There are more sophisticated ways to extract the key edges, but for the purposes of this exercise we'll only keep ones that have weight higher than the mean for the network. In igraph, we can delete edges using delete_edges(net, edges):

```{r}

cut.off <- mean(edge.df$weights) 

net.sp <- delete_edges(net5, E(net5)[weights<cut.off]) # delete_edges

par(mfrow=c(1,2))

plot(net5)

plot(net.sp) 

```

Another way to think about this is to plot the two tie types (practical & theorical) separately.

```{r}

E(net5)$width <- 1.5

plot(net5, edge.color=c("dark red", "slategrey")[(E(net5)$types=="practical")+1],
     vertex.color="gray40", layout=layout.circle)

```

Plot the two links separately:

```{r}

net.p <- net5 - E(net5)[E(net5)$types=="practical"] # another way to delete edges

net.t <- net5 - E(net5)[E(net5)$types=="theorical"]

par(mfrow=c(1,2))

plot(net.p, vertex.color="orange", main="Tie: practical")

plot(net.t, vertex.color="lightsteelblue2", main="Tie: theorical")

```

Make sure the nodes stay in place in both plots:

```{r}

l <- layout_with_fr(net5)

par(mfrow=c(1,2))

plot(net.p, vertex.color="orange", layout=l, 
     main="Tie: practical")

plot(net.t, vertex.color="lightsteelblue2", 
     layout=l, main="Tie: theorical")

```

**Interactive plotting with tkplot**

The "tkplot" might be a useful option for you if you want to tweak slightly the layout of a small graph. After adjusting the layout manually, you can get the coordinates of the nodes and use them for other plots. tkplot and its companion functions serve as an interactive graph drawing facility. 

```{r}

tkid <- tkplot(net5) #tkid is the id of the tkplot that will open

l <- tkplot.getcoords(tkid) # grab the coordinates from tkplot

tk_close(tkid, window.close = T) 

plot(net5, layout=l)

```

**Other ways to represent a network**

At this point it might be useful to provide a quick reminder that there are many ways to represent a network not limited to a hairball plot. For example, here is a quick heatmap of the network matrix:

```{r}

netm <- get.adjacency(net5, attr="weights", sparse=F)

colnames(netm) <- V(net5)$Courses

rownames(netm) <- V(net5)$Courses

palf <- colorRampPalette(c("cadetblue2", "firebrick3")) # Color interpolation

heatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(100),  # Draw a Heat Map
    
            scale="none", margins=c(10,10) )

```

**Plotting two-mode networks with igraph**

 As with one-mode networks, we can modify the network object to include the visual properties that will be used by default when plotting the network. Notice that this time we will also change the shape of the nodes - Courses outlets will be squares, and their users will be circles.

```{r}

V(net6)$color <- c("steel blue", "orange")[V(net6)$type+1]

V(net6)$shape <- c("square", "circle")[V(net6)$type+1]

V(net6)$label <- ""

V(net6)$label[V(net6)$type==F] <- nodes6$Courses[V(net6)$type==F] # *******

V(net6)$label.cex=.8

V(net6)$label.font=2

plot(net6, vertex.label.color="white", vertex.size=(2-V(net6)$type)*8) 

```

Igraph also has a special layout for bipartite networks (though it doesn't always work great, and you might be better off generating your own two-mode layout).

```{r}

plot(net6, vertex.label=NA, vertex.size=10, layout=layout_as_bipartite) 

```

Using text as nodes may be helpful at times:

```{r}

plot(net6, vertex.shape="none", vertex.label=as.character(nodes6$Courses),

     vertex.label.color=as.character(V(net6)$color), vertex.label.font=2, 

     vertex.label.cex=0.6, edge.color="gray70",  edge.width=2)

```